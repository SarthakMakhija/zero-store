package block

import (
	"encoding/binary"
	"github.com/SarthakMakhija/zero-store/kv"
)

// Block represents the in-memory representation of Block.
//
// Each block contains encoded key/value pairs, and keyValueBeginOffsets. The reason for storing keyValueBeginOffsets is to allow
// binary search for a key within each block.
type Block struct {
	data                 []byte
	keyValueBeginOffsets []uint16
}

// newBlock creates a new instance of Block.
// data is the encoded key/value pairs generated by block.Builder.
func newBlock(data []byte, keyValueBeginOffsets []uint16) Block {
	return Block{
		data:                 data,
		keyValueBeginOffsets: keyValueBeginOffsets,
	}
}

// Encode encodes the block to byte slice.
/*
// blocking encoding looks like the following:
  -------------------------------------------------------------------------------------------------------------------------
 | encoded key/value  | encoded key/value  |....| encoded key/value  | 0 | 48 | 120 | ...... |3088|          2 bytes 	   |
  -------------------------------------------------------------------------------------------------------------------------
  <--------------------------Encoded data---------------------------<-- Begin offsets of keys ---><-Number of begin offsets->
*/
func (block Block) Encode() []byte {
	data := block.data
	data = append(data, block.encodeKeyValueBeginOffsets()...)

	numberOfKeyValueBeginOffsets := make([]byte, Uint16Size)
	binary.LittleEndian.PutUint16(numberOfKeyValueBeginOffsets, uint16(len(block.keyValueBeginOffsets)))

	data = append(data, numberOfKeyValueBeginOffsets...)
	return data
}

// DecodeToBlock decodes the given byte slice to the Block.
//
// The last 2 bytes denote the number of keyValueBeginOffsets.
// The size of keyValueBeginOffsets = number of keyValueBeginOffsets * 2 bytes (each offset is an uint16).
// So, the (length of the data) minus (size of keyValueBeginOffsets) minus (2 bytes which denote the number of keyValueBeginOffsets)
// give the start offset of keyValueBeginOffsets or the end offset of key/value encoded data.
func DecodeToBlock(data []byte) Block {
	numberOfOffsets := binary.LittleEndian.Uint16(data[len(data)-Uint16Size:])
	startOfOffsets := uint16(len(data)) - uint16(Uint16Size) - numberOfOffsets*uint16(Uint16Size)
	offsetsBuffer := data[startOfOffsets : len(data)-Uint16Size]

	keyValueBeginOffsets := make([]uint16, 0, numberOfOffsets)
	for index := 0; index < len(offsetsBuffer); index += Uint16Size {
		keyValueBeginOffsets = append(keyValueBeginOffsets, binary.LittleEndian.Uint16(offsetsBuffer[index:]))
	}
	return Block{
		data:                 data[:startOfOffsets],
		keyValueBeginOffsets: keyValueBeginOffsets,
	}
}

// SeekToKey creates an iterator (/block iterator) that is positioned at a key which is greater or equal to the given key.
func (block Block) SeekToKey(key kv.Key) *Iterator {
	iterator := &Iterator{
		block: block,
	}
	iterator.seekToGreaterOrEqual(key)
	return iterator
}

// encodeKeyValueBeginOffsets encodes all the keyValueBeginOffsets to byte slice using LittleEndian encoding.
func (block Block) encodeKeyValueBeginOffsets() []byte {
	offsetBuffer := make([]byte, Uint16Size*len(block.keyValueBeginOffsets))
	offsetIndex := 0
	for _, offset := range block.keyValueBeginOffsets {
		binary.LittleEndian.PutUint16(offsetBuffer[offsetIndex:], offset)
		offsetIndex += Uint16Size
	}
	return offsetBuffer
}
